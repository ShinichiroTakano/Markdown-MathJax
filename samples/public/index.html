<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css" >
    <title>samples</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>
    <script>
      MathJax.Hub.Config({
        skipStartupTypeset: true, // ページロード時のmathjax発動禁止
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        },
        "HTML-CSS": {
          availableFonts: ["TeX"]
        }
      });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured"></script>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but samples doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <div id="content" class="markdown-body"></div>
<input id="hidden" type="hidden" value="それでは実際に重回帰モデルを作成していきましょう。モデルを作成する為には、まず目的変数と説明変数を表す変数を作成し、それをセットでモデル学習を行う必要があります。重回帰モデルをpythonで作成する場合には、まず`scikit-learn.linear_model`から`LinearRegression`をインポートします。
- aaaaa
 - bbbb
 - cccc

* 順序無しリストのアイテム
 * サブアイテムはタブもしくは4つのスペースでインデントする
* 順序無しリストの別のアイテム


1. 番号付きリスト1
  1. 番号付きリスト1_1
  1. 番号付きリスト1_2
1. 番号付きリスト2
1. 番号付きリスト3

# 見出し1
## 見出し2
### 見出し3
#### 見出し4
##### 見出し5
###### 見出し6

    class User
        def 

normal *italic* normal
normal _italic_ normal

normal **bold** normal
normal __bold__ normal

normal ***bold*** normal
normal ___bold___ normal

***

___

---

*    *    *

[Google先生](https://www.google.co.jp/)
https://www.google.co.jp/

```python
def factorial(x):
    if x == 0:
        return 1
    else:
        return x * factorial(x - 1)
```

　```
　class Hoge
　  def hoge
　    print 'hoge'
　  end
　end
　```

|header1|header2|header3|
|:--|--:|:--:|
|align left|align right|align center|
|a|b|c|


> お世話になります。xxxです。
> 
> ご連絡いただいた、バグの件ですが、仕様です。

$$
    y = a_1X_1+a_2X_2+a_3X_3+...+a_0
$$


`from sklearn.linear_model import LinearRegression`

`scikit-learn`でモデルを作成する際には、まずモデルを表す箱を準備し、その箱を表す変数へ代入する必要があります。具体的には、箱を表す変数名をmodelとした場合、下記のように記述します。

`model = LinearRegression()`

箱の準備が終わったら、いよいよモデルの学習です。モデルの学習には`fit`関数を使い、引数の中に、説明変数、目的変数の順番で記述をします。具体的には、説明変数を表す変数名をX、目的変数を表す変数名をyとすると、下記のように記述できます。

`model.fit(X,y)`

モデルの予測精度をさらに改善するために、説明変数の対数化による特徴量の生成を行なってみましょう。    
動画でも解説しましたが、目的変数と説明変数の散布図を描画したとき、指数関数のような分布となる場合に、説明変数を対数化することで直線的な分布に近づけることができ、線形回帰モデルへの当てはまりがよくなる可能性があります。  

では、実際に対数化を行なってみましょう。  
はじめに、目的変数mpgと説明変数displacementの散布図をもう一度確認します。  

![mpg_displacement.png](https://static-dev.quest.signate.jp/tasks/21727805-1868-471d-93c4-4ec1d59bc932/01/mpg_displacement.png)

指数関数のように、曲線を描くようなデータ分布となることがわかります。  
よって、説明変数displacementを対数化することでより直線的な分布に近づけることができそうです。  

対数化を行うには、`numpy`ライブラリの`log`関数を使用します。  
引数として、DataFrameの対数化したいカラムを与えます。

`np.log(DataFrameを代入した変数['対数化したいカラム名'])`

また、対数化したカラムは、DataFrameの新しいカラムとして追加しましょう。

`DataFrameを代入した変数['新たなカラム名'] = np.log(DataFrameを代入した変数['対数化したいカラム名'])`

もともとのDataFrameにはないカラム名を指定して値を代入した場合、新しいカラムとしてDataFrameに追加されます。">
    </div>
    <!-- built files will be auto injected -->
    <script>
      // console.log('MathJax', MathJax)
        window.addEventListener("DOMContentLoaded", main);
        window.addEventListener("hashchange", main);
        
        var get = $.get;
        marked.setOptions({
          renderer: new marked.Renderer(),
          gfm: true,
          tables: true,
          breaks: true,
          pedantic: false,
          sanitize: false,
          smartLists: false,
          smartypants: false
        });
        
        function main(){
          // ルーティング
          var name = "";
          if( location.hash.length <= 1 ){
            name = "index.md";
            location.hash = "#" + name;
          }else{
            name = location.hash.slice(1);
          }
          const text = document.getElementById('hidden').value
          console.log('text', text)
          // ページ内リンクなのでhistory.pushStateする必要はない
          // markedにlatexタグ食わせると&<>とかがエスケープされるので<pre />で包んで退避
          // ちなみに```mathとかで<pre><code class="lang-math">になったのはエスケープされるので注意
          var PREFIX = "<pre><code class=\"lang-math\">";
          var SUFFIX = "</code></pre>";
          var reg = new RegExp(
            ("(?:" + PREFIX + "([\\s\\S]*?)" + SUFFIX + ")")
              .replace(/\//g, "\/"),
            "gm");
          var wraped = text.split("$$")
            .reduce(function(sum, str, i){
              return i % 2 === 0 ?
                      sum + str :
                      sum + PREFIX + str + SUFFIX;
            }, "");
          var html = marked(wraped);
          // 退避したlatexタグを$$で包み直す
          var _html = html;
          var tuple = null;
          console.log('reg', reg)
          while(tuple = reg.exec(html)){
            console.log('tuple', tuple)
            _html = _html.split(tuple[0]).join("$$" + tuple[1] + "$$");
            // console.log('reg.exec(html)', reg.exec(html))
          }
          // mathjaxで処理
          var div = document.getElementById("content");
          div.innerHTML = _html;
          MathJax.Hub.Configured();
          MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
        }
    </script>
  </body>
</html>
